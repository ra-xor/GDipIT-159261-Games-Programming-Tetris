// Kaitlin Dixon, 25006454 - Navid Rahimi, 24017038 - Ari Lewis-Clarke, 24016664

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class Tetris extends GameEngine {
	// Entry point for the game
	public static void main(String[] args) {
		createGame(new Tetris(), 30);
	}

	// Game state variables
	boolean moveLeftPressed, moveRightPressed, rotatePressed, moveDownPressed, dropPressed;
	boolean holdLeft, holdRight, holdDown;
	boolean isPaused = false;
	int pauseMenuSelection = 0;
	String[] pauseMenuOptions = {"Resume", "Help", "Quit"};
	boolean isResuming = false;
	boolean showHelp = false;
	boolean showCountdown = false;
	long countdownStartTime;
	int countdownSeconds = 3;
	boolean isGameOver = false;

	// Board configuration and state
	final int WIDTH = 10;
	final int HEIGHT = 20;
	int[][] grid = new int[WIDTH][HEIGHT];
	Color[] tileColors = {black, cyan, blue, orange, yellow, green, pink, red};
	int playerScore = 0;
	int currentLevel = 1;

	// Timing variables for movement and update pacing
	float tickDelay = 0.15f;
	float tickTime = 0f;
	float gameStepDelay = 1f;
	float gameStepTime = 0f;

	// Tetromino piece position and shape
	int pieceColor = 1;
	int pieceX = WIDTH / 2;
	int pieceY = 0;
	int[][] activeShape = {{0,0}, {0,1}, {1,1}, {1,2}};

	// All tetromino shapes
	int[][][] shapes = {
			{{-1, 0}, {0, 0}, {1, 0}, {2, 0}},
			{{-1, 0}, {0, 0}, {1, 0}, {1, 1}},
			{{-1, 1}, {-1, 0}, {0, 0}, {1, 0}},
			{{0, 0}, {0, 1}, {1, 0}, {1, 1}},
			{{-1, 1}, {0, 1}, {0, 0}, {1, 0}},
			{{-1, 0}, {0, 0}, {1, 0}, {0, 1}},
			{{-1, 0}, {0, 0}, {0, 1}, {1, 1}}
	};

	// Initialize the game window and board
	public void init() {
		setWindowSize(350, 420);
		clearBoard();
	}

	public void restartGame() {
		playerScore = 0;
		currentLevel = 1;
		tickTime = 0f;
		gameStepTime = 0f;
		isPaused = false;
		showHelp = false;
		showCountdown = false;
		isGameOver = false;
		pauseMenuSelection = 0;
		clearBoard();
	}

	// Update the game state every frame
	public void update(double dt) {
		// Stop updating if the game is over
		if (isGameOver) return;
		// Countdown delay before resuming game, game resumes in 3 seconds but sped up by 1.5x
		if (showCountdown) {
			long elapsed = (long)((System.currentTimeMillis() - countdownStartTime) / (1000 / 1.5));
			if (elapsed >= countdownSeconds) {
				showCountdown = false; // Resume game
			}
			return; // Doesnt process game logic during countdown
		}
		boolean manualMove = false;
		if (isPaused) return;

		tickTime += (float) dt;
		gameStepTime += (float) dt;

		// Handle repeated movement input
		if (tickTime > tickDelay) {
			tickTime -= tickDelay;
			if (moveLeftPressed || holdLeft) {
				moveLeft();
				moveLeftPressed = false;
			}
			if (moveRightPressed || holdRight) {
				moveRight();
				moveRightPressed = false;
			}
			if (moveDownPressed || holdDown) {
				stepDown();
				moveDownPressed = false;
				manualMove = true;
			}
			if (rotatePressed) {
				rotatePiece();
				rotatePressed = false;
			}
			if (dropPressed) {
				instantDrop();
				dropPressed = false;
				manualMove = true;
			}
		}

		// Move the tetromino down automatically over time
		if (gameStepTime > gameStepDelay) {
			gameStepTime -= gameStepDelay;
			if (!manualMove) stepDown();
		}
	}

	// Draw the current frame (required by GameEngine)
	@Override
	public void paintComponent() {
		changeBackgroundColor(black);
		clearBackground(mWidth, mHeight);

		// Draw the border walls
		changeColor(128, 128, 128);
		for (int y = 0; y <= HEIGHT; y++) {
			drawSolidRectangle(1, y * 20 + 1, 18, 18);
			drawSolidRectangle((WIDTH + 1) * 20 + 1, y * 20 + 1, 18, 18);
		}
		for (int x = 0; x < WIDTH; x++) {
			drawSolidRectangle((x + 1) * 20 + 1, HEIGHT * 20 + 1, 18, 18);
		}

		// Draw all placed tiles on the board
		for (int y = 0; y < HEIGHT; y++) {
			for (int x = 0; x < WIDTH; x++) {
				changeColor(tileColors[grid[x][y]]);
				drawSolidRectangle((x + 1) * 20 + 1, y * 20 + 1, 18, 18);
			}
		}

		// Shows countdown numbers on screen
		if (showCountdown) {
			long elapsed = (long)((System.currentTimeMillis() - countdownStartTime) / (1000 / 1.5));
			long remaining = countdownSeconds - elapsed;

			changeColor(white);
			if (remaining > 0) {
				drawBoldText(150, 200, "" + remaining, 50);
			} else {
				drawBoldText(130, 200, "Go!", 50);
			}
			return;
		}

		// Below is the game over screen
		if (isGameOver) {
			// Displays "Game Over!", displays final scores and restart instructions
			changeColor(white);
			drawBoldText(90, 130, "Game Over!", 30);
			drawText(80, 170, "Final Score: " + playerScore, 20);
			drawText(80, 190, "Level: " + currentLevel, 20);
			drawText(75, 230, "Press R to restart", 20);
			return;
		}

		// Below is help menu
		if (showHelp) {
			// Below are the instructions for the game
			changeColor(white);
			drawBoldText(90, 80, "How to Play", 24);
			drawText(50, 120, "← → : Move", 20);
			drawText(50, 150, "↑    : Rotate", 20);
			drawText(50, 180, "↓    : Soft Drop", 20);
			drawText(50, 210, "Space: Hard Drop", 20);
			drawText(50, 240, "Esc  : Pause", 20);
			drawText(50, 280, "Enter: Select Menu Option", 20);
			drawText(50, 330, "(Press Esc to go back)", 16);
			return;
		}

		// Below is paused menu
		if (isPaused) {
			// Below displays the pause menu options, when a user presses down or up arrow it will highlight the option
			// awaiting the user to press enter to select an option.
			changeColor(white);
			drawBoldText(100, 100, "Game Paused", 24);
			for (int i = 0; i < pauseMenuOptions.length; i++) {
				if (i == pauseMenuSelection) changeColor(yellow);
				else changeColor(white);
				drawText(100, 150 + i * 30, pauseMenuOptions[i], 20);
			}
			return;
		}

		// Draw the current falling piece
		for (int[] block : activeShape) {
			int px = pieceX + block[0];
			int py = pieceY + block[1];
			changeColor(tileColors[pieceColor]);
			drawSolidRectangle((px + 1) * 20 + 1, py * 20 + 1, 18, 18);
		}

		// Draw the score and level
		changeColor(black);
		drawSolidRectangle(WIDTH * 20 + 45, 0, mWidth - WIDTH * 20, mHeight);

		changeColor(white);
		drawText(265, 45, "SCORE:", 18);
		drawText(265, 65, toString(playerScore), 18);
		drawText(265, 85, "Level:", 18);
		drawText(265, 105, toString(currentLevel), 18);
	}

	// Clear the board and start with a new piece
	public void clearBoard() {
		for (int y = 0; y < HEIGHT; y++)
			for (int x = 0; x < WIDTH; x++)
				grid[x][y] = 0;

		spawnPiece(0);
	}

	// Spawn a new tetromino at the top
	public void spawnPiece(int id) {
		pieceX = WIDTH / 2;
		pieceY = 0;

		for (int i = 0; i < 4; i++) {
			activeShape[i][0] = shapes[id][i][0];
			activeShape[i][1] = shapes[id][i][1];
			int tx = pieceX + activeShape[i][0];
			int ty = pieceY + activeShape[i][1];
			// Ends game if new piece overlaps existing blocks
			if (grid[tx][ty] != 0) {
				isGameOver = true;
				return;
			}
		}
		pieceColor = id + 1;
	}

	// Check if the current piece is touching the ground or another piece
	public boolean isLanded() {
		for (int[] block : activeShape) {
			int x = pieceX + block[0];
			int y = pieceY + block[1];
			if (y == HEIGHT - 1 || grid[x][y + 1] != 0) return true;
		}
		return false;
	}

	// Check and clear completed rows, update score and speed
	public void checkCompletedRows() {
		int linesCleared = 0;
		int y = 0;

		while (y < HEIGHT) {
			boolean full = true;
			for (int x = 0; x < WIDTH; x++) {
				if (grid[x][y] == 0) {
					full = false;
					break;
				}
			}

			if (full) {
				linesCleared++;
				for (int row = y; row > 0; row--) {
					for (int x = 0; x < WIDTH; x++) {
						grid[x][row] = grid[x][row - 1];
					}
				}
				for (int x = 0; x < WIDTH; x++) {
					grid[x][0] = 0;
				}
			} else {
				y++;
			}
		}

		int basePoints = 1500;
		switch (linesCleared) {
			case 1 -> playerScore += basePoints * currentLevel;
			case 2 -> playerScore += (basePoints * 2) * currentLevel;
			case 3 -> playerScore += (basePoints * 3) * currentLevel;
			case 4 -> playerScore += (basePoints * 5) * currentLevel;
		}

		int newLevel = (playerScore / 5000) + 1;
		if (newLevel > currentLevel) {
			currentLevel = newLevel;
			gameStepDelay = Math.max(0.1f, 1f - (currentLevel - 1) * 0.1f);
		}
	}

	// Move the current piece left
	public void moveLeft() {
		for (int[] block : activeShape) {
			int x = pieceX + block[0];
			int y = pieceY + block[1];
			if (x == 0 || grid[x - 1][y] != 0) return;
		}
		pieceX--;
	}

	// Move the current piece right
	public void moveRight() {
		for (int[] block : activeShape) {
			int x = pieceX + block[0];
			int y = pieceY + block[1];
			if (x == WIDTH - 1 || grid[x + 1][y] != 0) return;
		}
		pieceX++;
	}

	// Move the piece down one step or lock it in place
	public void stepDown() {
		if (isLanded()) {
			for (int[] block : activeShape) {
				int x = pieceX + block[0];
				int y = pieceY + block[1];
				grid[x][y] = pieceColor;
			}
			checkCompletedRows();
			spawnPiece(rand(7));
		} else {
			pieceY++;
		}
	}

	// Drop the piece instantly to the bottom
	public void instantDrop() {
		while (!isLanded()) pieceY++;
		for (int[] block : activeShape) {
			int x = pieceX + block[0];
			int y = pieceY + block[1];
			grid[x][y] = pieceColor;
		}
		checkCompletedRows();
		spawnPiece(rand(7));
	}

	// Rotate the tetromino if there's room
	public void rotatePiece() {
		for (int[] block : activeShape) {
			int x = pieceX + block[1];
			int y = pieceY - block[0];
			if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT || grid[x][y] != 0) return;
		}
		for (int i = 0; i < 4; i++) {
			int temp = activeShape[i][0];
			activeShape[i][0] = activeShape[i][1];
			activeShape[i][1] = -temp;
		}
	}

	// Handle key press inputs
	public void keyPressed(KeyEvent e) {
		// Closes help screen with ESC key
		if (showHelp && e.getKeyCode() == KeyEvent.VK_ESCAPE) {
			showHelp = false;
			isPaused = true;
			return;
		}
		// Restarts game with R key after game over
		if (isGameOver && e.getKeyCode() == KeyEvent.VK_R) {
			restartGame();
			return;
		}

		// Toggles the pause menu with ESC key, can pause or unpause the game with ESC key
		if (!showHelp && e.getKeyCode() == KeyEvent.VK_ESCAPE) {
			isPaused = !isPaused;
			return;
		}

		// Navigate and selects pause menu options
		if (isPaused) {
			// Below handles the up/down and enter keys in the pause menu
			if (e.getKeyCode() == KeyEvent.VK_UP)
				pauseMenuSelection = (pauseMenuSelection + pauseMenuOptions.length - 1) % pauseMenuOptions.length;
			else if (e.getKeyCode() == KeyEvent.VK_DOWN)
				pauseMenuSelection = (pauseMenuSelection + 1) % pauseMenuOptions.length;
			else if (e.getKeyCode() == KeyEvent.VK_ENTER) {
				switch (pauseMenuOptions[pauseMenuSelection]) {
					case "Resume" -> {
						showCountdown = true;
						countdownStartTime = System.currentTimeMillis();
						isPaused = false;
					}
					case "Help" -> {
						showHelp = true;
						isPaused = false;
					}
					case "Quit" -> System.exit(0);
				}
			}
			return;
		}

		switch (e.getKeyCode()) {
			case KeyEvent.VK_LEFT -> { moveLeftPressed = true; holdLeft = true; }
			case KeyEvent.VK_RIGHT -> { moveRightPressed = true; holdRight = true; }
			case KeyEvent.VK_DOWN -> { moveDownPressed = true; holdDown = true; }
			case KeyEvent.VK_UP -> rotatePressed = true;
			case KeyEvent.VK_SPACE -> dropPressed = true;
		}
	}

	// Handle key release inputs
	public void keyReleased(KeyEvent e) {
		switch (e.getKeyCode()) {
			case KeyEvent.VK_LEFT -> holdLeft = false;
			case KeyEvent.VK_RIGHT -> holdRight = false;
			case KeyEvent.VK_DOWN -> holdDown = false;
		}
	}
}
